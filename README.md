# Принципи програмування у моєму коді

Цей файл README.md описує, як різні принципи програмування демонструються у наданому коді.

## Принципи

### 1. DRY (Don't Repeat Yourself)
Принцип DRY дотримується шляхом інкапсуляції логіки для роботи з грошовими операціями у класі `Money`, що дозволяє уникнути повторення коду для управління сумами та їх відображення.
- [Клас Money](lab-1/Task1/Task1/Money.cs)

### 2. KISS (Keep It Simple, Stupid)
Код зберігає методи та класи простими та зрозумілими. Наприклад, клас `Money` має чіткі та лаконічні методи для відображення та маніпулювання грошовими сумами.
- [Клас Money](lab-1/Task1/Task1/Money.cs)
- [Клас Program](lab-1/Task1/Task1/Program.cs#L14-L20)

### 3. Принципи SOLID

#### S - Принцип єдиного обов'язку (Single Responsibility Principle)
Кожен клас у коді має одну відповідальність. Наприклад, клас `Money` відповідає лише за операції з грошима.
- [Клас Money](lab-1/Task1/Task1/Money.cs)
- [Клас Product](lab-1/Task1/Task1/Product.cs)

#### O - Принцип відкритості/закритості (Open/Closed Principle)
Класи спроектовані так, щоб бути відкритими для розширення, але закритими для модифікації. Наприклад, можна додавати нові типи продуктів шляхом розширення класу `Product`, не змінюючи його існуючий код.
- [Клас Product](lab-1/Task1/Task1/Product.cs)
- [Клас Warehouse](lab-1/Task1/Task1/Warehouse.cs)

#### L - Принцип підстановки Лісков (Liskov Substitution Principle)
Об'єкти суперкласу повинні заміщатися об'єктами підкласу без зміни функціональності. Хоча це прямо не показано в поточному коді, проектування класів `Product` та `WarehouseItem` з урахуванням цього принципу забезпечує сумісність.
- [Клас Warehouse](lab-1/Task1/Task1/Warehouse.cs)
- [Клас WarehouseItem](lab-1/Task1/Task1/WarehouseItem.cs)

#### I - Принцип розділення інтерфейсів (Interface Segregation Principle)
Цей принцип неявно демонструється в поточному коді, але може бути застосований, щоб забезпечити реалізацію класами конкретних інтерфейсів, які відповідають їх функціональності.

#### D - Принцип інверсії залежностей (Dependency Inversion Principle)
Вищі модулі не повинні залежати від нижчих модулів. Обидва повинні залежати від абстракцій. Наприклад, клас `Reporting` може бути спроектований таким чином, щоб залежати від інтерфейсу, а не безпосередньо від `Warehouse`.
- [Клас Reporting](lab-1/Task1/Task1/Reporting.cs)

### 4. YAGNI (You Aren't Gonna Need It)
Код уникає реалізації непотрібних функцій або складності. Реалізовані тільки необхідні методи та властивості у кожному класі.
- [Клас Program](lab-1/Task1/Task1/Program.cs)

### 5. Композиція замість успадкування (Composition Over Inheritance)
Код віддає перевагу композиції над успадкуванням, використовуючи екземпляри інших класів всередині класу для досягнення функціональності. Наприклад, клас `Warehouse` використовує об'єкти `WarehouseItem` для управління інвентарем.
- [Клас Warehouse](lab-1/Task1/Task1/Warehouse.cs)

### 6. Програмування на інтерфейси, а не на реалізації (Program to Interfaces, Not Implementations)
Цей принцип ілюструється проектуванням класів, які залежать від абстракцій (інтерфейсів), а не від конкретних реалізацій, хоча інтерфейси явно не визначені в поточному коді.

### 7. Fail Fast
Код спроектований так, щоб виявляти помилки на ранніх стадіях та відповідним чином їх обробляти. Наприклад, клас `Warehouse` забезпечує правильне управління кількістю інвентарю, генеруючи виключення для некоректних операцій.
- [Клас Warehouse](lab-1/Task1/Task1/Warehouse.cs)

## Посилання на код

- [Клас Program](lab-1/Task1/Task1/Program.cs)
- [Клас Money](lab-1/Task1/Task1/Money.cs)
- [Клас Product](lab-1/Task1/Task1/Product.cs)
- [Клас Warehouse](lab-1/Task1/Task1/Warehouse.cs)
- [Клас WarehouseItem](lab-1/Task1/Task1/WarehouseItem.cs)
- [Клас Reporting](lab-1/Task1/Task1/Reporting.cs)
